<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>W2</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style type="text/css">
    body
    {
        background: #000;
        color: #FFF;
        font-family: 'Ubuntu', sans-serif;
    }

    .heading {
        padding: 0px 0px 20px 0px;
        border-bottom: 1px solid #FFF;
    }

    a {
        color: #428bca;
        text-decoration: none;
        padding-bottom: 1px;
        border-bottom: 1px solid #428bca;
    }

    p {
        font-size: 15px;
        line-height: 1.5;
    }

    .row {
        max-width: 600px;
    }
    .container {
        padding: 20px;
    }
    
    .source {
        position: absolute;
        bottom: 20px;
        right: 10px;
    }

    .controls {
        margin-top: 12px;
    }

    button {
        padding: 8px 12px;
        margin-right: 8px;
        font-size: 14px;
        cursor: pointer;
        border-radius: 4px;
        border: none;
    }

    button.start { background: #2ecc71; color: #000; }
    button.stop  { background: #e74c3c; color: #000; }
    </style>
</head>
<body>
    <div class="container">
        <div class="row">
                <h1 class="heading"> Whistlerr</h1>

                <p> Whistlerr detects whistling sounds from the microphone using the Web Audio API.
                It's based on a research paper <a href='https://www.diva-portal.org/smash/get/diva2:836227/FULLTEXT01.pdf'>Human Whistle Detection and Frequency Estimation</a> by M. Nilsson.</p>
                <p>
                <strong><a id="clickhere" href="#">Click Here</a></strong> to start detecting. You'll need to give permission to access the microphone.
              </p>
              <p>Blow a whistle and watch as the particles swirl. Please excuse the false positives! :)</p>
                <p> <a href="https://github.com/shubhamjain/whistlerr" class="source">Github Source</a> </p>
        </div>

        <div>
            <div id="container" style="height: 50vh;"></div>
        </div>

        <div class="controls">
            <button id="startBtn" class="start">Iniciar detección</button>
            <button id="stopBtn" class="stop">Detener detección</button>
        </div>

        <script>
/*
  He integrado los módulos (bundle) tal cual venían en el archivo original,
  y solo he añadido control de parada mediante la variable global window.stopWhistle.
  Al pulsar "Detener detección" se pone window.stopWhistle = true y se cierran
  el MediaStream y AudioContext; whistleFinder deja de re-agendarse.
*/

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./demo.js":
/*!*****************!*\
  !*** ./demo.js ***!
  \*****************/
/***/ (function() {

window.whistlerr = __webpack_require__("./index.js");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ (function(module) {

var SMQT = __webpack_require__("./lib/smqt.js"),
    FFT = __webpack_require__("./lib/fft.js"),
    dspFilter = __webpack_require__("./lib/dspFilter.js"),
    jensenDiff = __webpack_require__("./lib/jensenDiff.js");

var raf = __webpack_require__("./node_modules/raf/index.js")

var config = {
    sampleRate: 44100,  // Audio Input sample rate
    maxLevel: 8,        // Maximum level of SMQT
    freqBinCount: 512,   // Size of FFT

    jDiffThreshold: 0.45,   // Jensen Difference Threshold
    whistleBlockThreshold: 25, // Ratio of bandpass and bandstop blocks for 500-5000Hz

    sampleThreshold: 10 // Threshold for postive samples / 50 samples

};

var setConfig = function (initConfig = {}) {
    config = {...config, ...initConfig};
};

var totalSamples = 0, positiveSamples = 0,
normData, fft, pbp,
pbs, maxpbp, sumAmplitudes,
minpbp, ratio, jDiff, i;

var timeBuf = new Uint8Array(config.freqBinCount); //time domain data

function whistleFinder(analyser, whistleCallback) {
    // If stop requested, just exit and avoid scheduling another frame
    if (window.stopWhistle) {
        // reset counters so next start is clean
        totalSamples = 0;
        positiveSamples = 0;
        return;
    }

    analyser.getByteTimeDomainData(timeBuf);

    SMQT.init(timeBuf, config.maxLevel).calculate();

    // FFT calculation of nomralized data
    fft = new FFT(config.freqBinCount, config.sampleRate);

    fft.forward(SMQT.normalize());

    pbp = dspFilter.bandpass(fft.spectrum, {
        sampleRate: config.sampleRate,
        fLower: 500,
        fUpper: 5000
    });

    pbs = dspFilter.bandstop(fft.spectrum, {
        sampleRate: config.sampleRate,
        fLower: 500,
        fUpper: 5000
    });

    // Calculating mean(pbs) max(pbp)
    maxpbp = 0; sumAmplitudes = 0; minpbp = 100;

    for (i = 0; i < config.freqBinCount / 2; i++) {

        // Since it's a TypedArray, we can't use _Math._ operations
        if (pbp[i] > maxpbp)
            maxpbp = pbp[i];

        if (pbp[i] < minpbp)
            minpbp = pbp[i];

        sumAmplitudes += Math.abs(pbs[i]);
    }

    meanpbs = sumAmplitudes / (i - 1);

    // Forming data for Jensen Difference
    sumAmplitudes = 0;
    for (i = 0; i < config.freqBinCount / 2; i++) {
        pbp[i] = (pbp[i] - minpbp) + 2 / config.freqBinCount;
        sumAmplitudes += pbp[i];
    }

    for (i = 0; i < config.freqBinCount / 2; i++)
        pbp[i] /= sumAmplitudes;

    ratio = maxpbp / (meanpbs + 1);
    jDiff = jensenDiff(pbp, config.freqBinCount);

    if (ratio > config.whistleBlockThreshold && jDiff > config.jDiffThreshold) {
        positiveSamples++;

        if (positiveSamples > config.sampleThreshold) {
            whistleCallback({
                ratio: ratio,
                jDiff: jDiff
            });
        }
    }

    if (totalSamples === 50) {
        totalSamples = 0;
        positiveSamples = 0;
    } else {
        totalSamples += 1;
    }

    // Only schedule the next frame if stop not requested.
    if (!window.stopWhistle) {
        raf(whistleFinder.bind(this, analyser, whistleCallback));
    } else {
        // cleanup counters
        totalSamples = 0;
        positiveSamples = 0;
    }
}

var whistlerr = function (whistleCallback) {
    var audioContext = new AudioContext();

    navigator.getUserMedia = (navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia ||
        navigator.msGetUserMedia);

    function getUserMedia(dictionary, callback, error) {
        try {
            if (!navigator.getUserMedia) {
                navigator.mediaDevices.getUserMedia(dictionary).then(callback).catch(error);
            } else {
                navigator.getUserMedia(dictionary, callback, error);
            }
        } catch (e) {
            alert('getUserMedia threw exception :' + e);
        }
    }

    function gotStream(stream) {
        // Expose stream & audioContext so external control can stop them
        window._whistlerr_stream = stream;
        window._whistlerr_audioContext = audioContext;

        // Create an AudioNode from the stream.
        var mediaStreamSource = audioContext.createMediaStreamSource(stream);
        // Connect it to the destination.
        var analyser = audioContext.createAnalyser();
        analyser.fftSize = config.freqBinCount;

        mediaStreamSource.connect(analyser);
        // reset stop flag and start finder
        window.stopWhistle = false;
        whistleFinder(analyser, whistleCallback);
    }

    getUserMedia({ audio: true }, gotStream, function () {
        alert("There was an error accessing audio input. Please check.");
    });
};

module.exports = {
    setConfig,
    detect: whistlerr,
    whistleFinder
};

/***/ }),

/***/ "./lib/dspFilter.js":
/*!**************************!*\
  !*** ./lib/dspFilter.js ***!
  \**************************/
/***/ (function(module) {

function bandPassFilter(spectrum, config){
    var spectrumClone = spectrum.slice(); // spectrumClone the Array

    var freqPerSpectrumElement = config.sampleRate / (spectrumClone.length * 2);

    for( var i = 0; spectrumClone[i] !== undefined; i++ ) {
        if( i * freqPerSpectrumElement < config.fLower || i * freqPerSpectrumElement > config.fUpper )
            spectrumClone[i] = 0.15;
    }

    return spectrumClone;
}

function bandStopFilter(spectrum, config){
    var spectrumClone = spectrum.slice(); // spectrumClone the Array

    var freqPerSpectrumElement = config.sampleRate / (spectrumClone.length * 2);

    for( var i = 0; spectrumClone[i] !== undefined; i++ ) {

        if( i * freqPerSpectrumElement > config.fLower && i * freqPerSpectrumElement < config.fUpper )
            spectrumClone[i] = 0.15;
    }

    return spectrumClone;
}

module.exports = {
    bandpass: bandPassFilter,
    bandstop: bandStopFilter
};

/***/ }),

/***/ "./lib/fft.js":
/*!********************!*\
  !*** ./lib/fft.js ***!
  \********************/
/***/ (function(module) {

// (Contenido original de FFT, sin cambios)
function setupTypedArray(name, fallback) {
  if (typeof this[name] !== "function" && typeof this[name] !== "object") {
    if (typeof this[fallback] === "function" && typeof this[fallback] !== "object") {
      this[name] = this[fallback];
    } else {
      this[name] = function(obj) {
        if (obj instanceof Array) {
          return obj;
        } else if (typeof obj === "number") {
          return new Array(obj);
        }
      };
    }
  }
}

setupTypedArray("Float32Array", "WebGLFloatArray");
setupTypedArray("Int32Array",   "WebGLIntArray");
setupTypedArray("Uint16Array",  "WebGLUnsignedShortArray");
setupTypedArray("Uint8Array",   "WebGLUnsignedByteArray");

function FourierTransform(bufferSize, sampleRate) {
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.bandwidth  = 2 / bufferSize * sampleRate / 2;

  this.spectrum   = new Float32Array(bufferSize/2);
  this.real       = new Float32Array(bufferSize);
  this.imag       = new Float32Array(bufferSize);

  this.peakBand   = 0;
  this.peak       = 0;

  this.getBandFrequency = function(index) {
    return this.bandwidth * index + this.bandwidth / 2;
  };

  this.calculateSpectrum = function() {
    var spectrum  = this.spectrum,
        real      = this.real,
        imag      = this.imag,
        bSi       = 2 / this.bufferSize,
        sqrt      = Math.sqrt,
        rval,
        ival,
        mag;

    for (var i = 0, N = bufferSize/2; i < N; i++) {
      rval = real[i];
      ival = imag[i];
      mag = sqrt(rval * rval + ival * ival);

      if (mag > this.peak) {
        this.peakBand = i;
        this.peak = mag;
      }

      spectrum[i] = mag;
    }
  };
}

function FFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.reverseTable = new Uint32Array(bufferSize);

  var limit = 1;
  var bit = bufferSize >> 1;

  var i;

  while (limit < bufferSize) {
    for (i = 0; i < limit; i++) {
      this.reverseTable[i + limit] = this.reverseTable[i] + bit;
    }

    limit = limit << 1;
    bit = bit >> 1;
  }

  this.sinTable = new Float32Array(bufferSize);
  this.cosTable = new Float32Array(bufferSize);

  for (i = 0; i < bufferSize; i++) {
    this.sinTable[i] = Math.sin(-Math.PI/i);
    this.cosTable[i] = Math.cos(-Math.PI/i);
  }
}

FFT.prototype.forward = function(buffer) {
  var bufferSize      = this.bufferSize,
      cosTable        = this.cosTable,
      sinTable        = this.sinTable,
      reverseTable    = this.reverseTable,
      real            = this.real,
      imag            = this.imag,
      spectrum        = this.spectrum;

  var k = Math.floor(Math.log(bufferSize) / Math.LN2);

  if (Math.pow(2, k) !== bufferSize) { throw "Invalid buffer size, must be a power of 2."; }
  if (bufferSize !== buffer.length)  {
    throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length;
  }

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    real[i] = buffer[reverseTable[i]];
    imag[i] = 0;
  }

  while (halfSize < bufferSize) {
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];

    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
    }

    halfSize = halfSize << 1;
  }

  return this.calculateSpectrum();
};

module.exports = FFT;

/***/ }),

/***/ "./lib/jensenDiff.js":
/*!***************************!*\
  !*** ./lib/jensenDiff.js ***!
  \**************************/
/***/ (function(module) {

// (Contenido original de jensenDiff)
var Hv_ = 5.545177444479573;

function Hv(arr) {
    var sum = 0;

    for( var i = 0; arr[i] !== undefined; i++)
        sum -= arr[i] * Math.log(arr[i]);

    return sum;
}

function HvHv_ ( arr, freqBinCount ) {
    var sum = 0;

    for( var i = 0; arr[i] !== undefined; i++) {
        var X = (arr[i] + 2 / freqBinCount) / 2;
        sum -= X * Math.log(X);
    }

    return sum;

}

function jensenDiff( spectrum, freqBinCount ) {
    return HvHv_(spectrum, freqBinCount) - (Hv(spectrum) + Hv_) / 2;
}

module.exports = jensenDiff;

/***/ }),

/***/ "./lib/smqt.js":
/*!*********************!*\
  !*** ./lib/smqt.js ***!
  \********************/
/***/ (function(module) {

// (Contenido original de SMQT)
var SMQT = {
    timeArr : [],
    smqtArr : [],

    maxLevel : 0,

    init : function( timeArr, maxLevel){
        this.timeArr = timeArr;
        this.maxLevel = maxLevel;

        return this;
    },

    calculate : function(){
        this.smqtArr = this.SMQT( this.timeArr, 1);

        return this;
    },

    addUp : function(a, b, c) {
        var catArr = b.concat(c);

        for(var i = 0; i < catArr.length ; i++) {
            a[i] += catArr[i];
        }

        return a;
    },

    SMQT : function( time_arr, currLevel )
    {
        if( currLevel === this.maxLevel + 1)
            return [];

        var U = [], one_set = [], zero_set = [], sum_samples = 0, avg_samples;

        // Step 1: Calculate the mean of all samples
        for( var i = 0; i < time_arr.length; i++ ) {
            sum_samples += time_arr[i];
        }

        avg_samples = sum_samples / time_arr.length;

        // Step 2 : Divide the samples into two set, one
        // above average and other below average.
        for (i = 0; i < time_arr.length; i++ ) {
            if( time_arr[i] >= avg_samples ) {
                U.push( 1 * Math.pow(2, this.maxLevel - currLevel) ); // conversion from binary "1" to its integer form
                one_set.push(time_arr[i]);
            } else {
                U.push(0);
                zero_set.push(time_arr[i]);
            }
        }

        return this.addUp(U, this.SMQT(one_set, currLevel + 1), this.SMQT(zero_set, currLevel + 1));
    },

    normalize : function(){
        for ( var i = 0; i < this.smqtArr.length; i++)
            this.smqtArr[i] = (this.smqtArr[i] - Math.pow(2, this.maxLevel - 1)) / Math.pow(2, this.maxLevel - 1);

        return this.smqtArr;
    }

};

module.exports = SMQT;

/***/ }),

/***/ "./node_modules/performance-now/lib/performance-now.js":
/***/ (function(module) {

// (contenido performance-now, inalterado)
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

/***/ }),

/***/ "./node_modules/raf/index.js":
/***/ (function(module) {

var now = __webpack_require__("./node_modules/performance-now/lib/performance-now.js")
  , root = typeof window === 'undefined' ? (typeof global !== 'undefined' ? global : this) : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	function __webpack_require__(moduleId) {
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// startup
/******/ 	var __webpack_exports__ = __webpack_require__("./demo.js");
/******/ 	
/******/ })()
;

// --- Configuración por defecto: ajustable ---
whistlerr.setConfig({
    sampleThreshold : 18
});

// Inicializamos bandera de parada por defecto en true (no ejecutar)
window.stopWhistle = true;

// Start/Stop helpers
function startDetection() {
    // If already running, ignore
    if (!window.stopWhistle) return;

    // Reset flags and start detection
    window.stopWhistle = false;
    // whistlerr.detect establecerá window._whistlerr_stream y window._whistlerr_audioContext
    whistlerr.detect(function(info){
        // Evitamos mostrar alert si hemos pedido detener
        if (!window.stopWhistle) {
            console.log("Silbido.");
			stopDetection();
			startRecoVoz();
        }
    });
}

function stopDetection() {
    // request stop
    window.stopWhistle = true;

    // stop the media tracks if present
    try {
        if (window._whistlerr_stream) {
            window._whistlerr_stream.getTracks().forEach(function(t){ try { t.stop(); } catch(e){} });
            window._whistlerr_stream = null;
        }
    } catch(e){}

    // close audio context if present
    try {
        if (window._whistlerr_audioContext && typeof window._whistlerr_audioContext.close === 'function') {
            window._whistlerr_audioContext.close();
            window._whistlerr_audioContext = null;
        }
    } catch(e){}
}

// Botones: clickhandlers
document.getElementById('startBtn').addEventListener('click', function(e){
    e.preventDefault();
    startDetection();
});

document.getElementById('stopBtn').addEventListener('click', function(e){
    e.preventDefault();
    stopDetection();
});

// Enlace clickhere también inicia
document.getElementById('clickhere').addEventListener('click', function(e){
    e.preventDefault();
    startDetection();
});








//_____ PARTE RECOVOZ ____
	
	
	let escuchandoVoz = false;
	let recognition;
	// Comprobar compatibilidad
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      alert("Tu navegador no soporta la API de reconocimiento de voz.");
    } else {
		console.log ("Iniciando SpeechRecognition...");
      recognition = new SpeechRecognition();
      recognition.lang = "es-ES"; 			// idioma español
      recognition.continuous = false; 		// sigue escuchando
      recognition.interimResults = false;

      recognition.onresult = (event) => {
        console.log ("onresult");
		const results = event.results;
        const frase = results[results.length - 1][0].transcript.trim().toLowerCase();
      //  document.getElementById("texto").innerText = "Has dicho: " + frase;
		console.log (frase);
		vozReconocida (frase);
      };

      recognition.onerror = (event) => {
        console.error("Error de reconocimiento: ", event.error);
      };

      recognition.onend = () => {
		console.log ("onend");
		document.body.style.background = "#000000";
		//iniciarEscucharSilbido();
		//document.querySelector("#activateAudioContext").click();
		escuchandoVoz = false;
		//setTimeout (function(){startRecoSilvido();}, 2*1000);
		//startRecoSilvido();
		startDetection();
      };	
    }
	
	  function startRecoVoz(){
			if (!escuchandoVoz){
				document.body.style.background = "#ff0000";
				escuchandoVoz = true;
				recognition.start();
			}	
		}
	
	
	// __ PARTE COMANDOS__
	
	function vozReconocida (comando){			// Palabras clave y acciones
        if (comando.includes("uno") || comando.includes("salón")) {
			envioDatos ('EnviaPorRF,24,1000102#');			  
        }
		if (comando.includes("6") || comando.includes("seis") || comando.includes("ambiente")) {	//
			envioDatos   ('EnviaPorRF,24,3342336#');		// Conmuta 6 (rf3off)	
		}
        if (comando.includes("audio") && comando.includes("bluetooth")) {	//if ((comando.includes("6") || comando.includes("seis")) && comando.includes("enciende")){							
			envioDatos   ('rf4on');
			setTimeout (function(){envioDatos('EnviaPorRF,24,1000070#');}, 2*1000);
		}
		if (comando.includes("audio") && comando.includes("ordenador")) {		
			envioDatos('rf4on');
			setTimeout (function(){envioDatos('EnviaPorRF,24,1000050#');}, 2*1000);
		}
		if (comando.includes("audio") && comando.includes("televisión")) {		
			envioDatos('rf4on');
			setTimeout (function(){envioDatos('EnviaPorRF,24,1000060#');}, 2*1000);
		}
		if (comando.includes("audio") && comando.includes("apaga")) {		
			envioDatos('EnviaPorRF,24,1000090#');
			setTimeout (function(){envioDatos('rf4off');}, 5*1000);
		}
		if ((comando.includes("4") || comando.includes("cuatro")) && comando.includes("apaga")){								
			envioDatos('rf4off');
		}
		if ((comando.includes("2") || comando.includes("dos")) && comando.includes("apaga")){								
			envioDatos('rf2off');
		}
		if ((comando.includes("2") || comando.includes("dos")) && comando.includes("enciende")){								
			envioDatos('rf2on');
		}
		if (comando.includes("habitación") || (comando.includes("2") || comando.includes("dos")) && comando.includes("canal")){								
			envioDatos('rf2on');
			setTimeout (function(){envioDatos('rf2off');}, 10*1000);
		}
		
		if (comando.includes("rojo")) {
          document.body.style.background = "red";
        }
        if (comando.includes("negro")) {
          document.body.style.background = "black";
        }
	}
	
	
	function envioDatos (datos){
		let ruta = "http://" + "192.168.1.100" + "/" + datos;
		console.log (ruta);
		fetch(ruta, {
			signal: AbortSignal.timeout(2500),
			method: "GET",
			headers: {"Content-type": "text/html"}
		})
		.then(response => response.text()) 	
		.then(respuesta => {console.log("Resp http: " + respuesta);	})
		.catch(err => {console.log("ERROR: " + err); });
	}
	































        </script>
    </div>
</body>
</html>


