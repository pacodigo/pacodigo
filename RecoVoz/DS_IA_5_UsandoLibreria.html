<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Detector de silbidos (archivo único)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;line-height:1.4;padding:18px;color:#111;background:#f7f7f8}
    h1{font-size:1.25rem;margin:0 0 8px}
    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .card{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.06);margin-top:12px}
    label{font-size:0.85rem}
    input[type=range]{width:220px}
    button{padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:#fff;cursor:pointer}
    #visualizer{width:100%;height:140px;background:#0b0b0b;border-radius:8px}
    #log{height:140px;overflow:auto;font-family:monospace;background:#111;color:#dff;padding:8px;border-radius:6px}
    .small{font-size:0.85rem;color:#444}
    .row{display:flex;gap:12px;align-items:center}
    .grow{flex:1}
  </style>
</head>
<body>
  <h1>Detector de silbidos — archivo único</h1>
  <p class="small">Incluye la librería proporcionada (inline). Ajusta sensibilidad y duración mínima del silbido. Pulsa <strong>Iniciar escucha</strong> para permitir el micrófono.</p>

  <div class="card">
    <div class="controls">
      <button id="startBtn">Iniciar escucha</button>
      <button id="stopBtn" disabled>Parar escucha</button>

      <div class="row">
        <label for="sensitivity">Sensibilidad</label>
        <input id="sensitivity" type="range" min="5" max="100" value="25" />
        <span id="sensVal">25</span>
      </div>

      <div class="row">
        <label for="duration">Duración mínima (ms)</label>
        <input id="duration" type="number" min="50" max="3000" value="200" style="width:90px" />
      </div>

      <label><input type="checkbox" id="autoAdj" checked /> Ajuste automático de sensibilidad ante ruido continuo</label>
      <label><input type="checkbox" id="playAlert" /> Reproducir alerta sonora</label>
    </div>

    <div style="margin-top:12px">
      <canvas id="visualizer"></canvas>
    </div>
  </div>

  <div class="card">
    <div style="display:flex;gap:12px;align-items:center">
      <div class="grow">
        <div id="log"></div>
      </div>
      <div style="width:230px">
        <div class="small">Última detección</div>
        <div id="last" style="font-family:monospace;padding:8px;background:#f1f1f1;border-radius:6px;margin-top:6px">—</div>
      </div>
    </div>
  </div>

  <!-- LIBRARY (user uploaded build). This is the exact build file inline so it sets window.whistlerr -->
  <script>
// --- start of whistle.build.js (inlined) ---
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./demo.js":
/*!*****************!*\
  !*** ./demo.js ***!
  \*****************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("window.whistlerr = __webpack_require__(/*! ./ */ \"./index.js\");\n\n//# sourceURL=webpack://whistlerr/./demo.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*
  !*** ./index.js ***!
  \******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var SMQT = __webpack_require__(/*! ./lib/smqt */ \"./lib/smqt.js\"),\n\tFFT = __webpack_require__(/*! ./lib/fft */ \"./lib/fft.js\"),\n\tdspFilter = __webpack_require__(/*! ./lib/dspFilter */ \"./lib/dspFilter.js\"),\n\tjensenDiff = __webpack_require__(/*! ./lib/jensenDiff */ \"./lib/jensenDiff.js\");\n\nvar raf = __webpack_require__(/*! raf */ \"./node_modules/raf/index.js\")\n\nvar config = {\n\tsampleRate: 44100,  // Audio Input sample rate\n\tmaxLevel: 8,        // Maximum level of SMQT\n\tfreqBinCount: 512,   // Size of FFT\n\n\tjDiffThreshold: 0.45,   // Jensen Difference Threshold\n\twhistleBlockThreshold: 25, // Ratio of bandpass and bandstop blocks for 500-5000Hz\n\n\tsampleThreshold: 10 // Threshold for postive samples / 50 samples\n\n};\n\nvar setConfig = function (initConfig = {}) {\n\tconfig = {...config, ...initConfig};\n};\n\nvar totalSamples = 0, positiveSamples = 0,\r\nnormData, fft, pbp,\r\npbs, maxpbp, sumAmplitudes,\r\nminpbp, ratio, jDiff, i;\r\n\r\nvar timeBuf = new Uint8Array(config.freqBinCount); //time domain data\r\n\r\nfunction whistleFinder(analyser, whistleCallback) {\r\n\tanalyser.getByteTimeDomainData(timeBuf);\r\n\r\n\tSMQT.init(timeBuf, config.maxLevel).calculate();\r\n\r\n\t// FFT calculation of nomralized data\r\n\tfft = new FFT(config.freqBinCount, config.sampleRate);\r\n\r\n\tfft.forward(SMQT.normalize());\r\n\r\n\tpbp = dspFilter.bandpass(fft.spectrum, {\r\n\t\tsampleRate: config.sampleRate,\r\n\t\tfLower: 500,\r\n\t\tfUpper: 5000\r\n\t});\r\n\r\n\tpbs = dspFilter.bandstop(fft.spectrum, {\r\n\t\tsampleRate: config.sampleRate,\r\n\t\tfLower: 500,\r\n\t\tfUpper: 5000\r\n\t});\r\n\r\n\t// Calculating mean(pbs) max(pbp)\r\n\tmaxpbp = 0; sumAmplitudes = 0; minpbp = 100;\r\n\r\n\tfor (i = 0; i < config.freqBinCount / 2; i++) {\r\n\r\n\t\t// Since it's a TypedArray, we can't use _Math._ operations\r\n\t\tif (pbp[i] > maxpbp)\r\n\t\t\tmaxpbp = pbp[i];\r\n\r\n\t\tif (pbp[i] < minpbp)\r\n\t\t\tminpbp = pbp[i];\r\n\r\n\t\tsumAmplitudes += Math.abs(pbs[i]);\r\n\t}\r\n\r\n\tmeanpbs = sumAmplitudes / (i - 1);\r\n\r\n\t// Forming data for Jensen Difference\r\n\tsumAmplitudes = 0;\r\n\tfor (i = 0; i < config.freqBinCount / 2; i++) {\r\n\t\tpbp[i] = (pbp[i] - minpbp) + 2 / config.freqBinCount;\r\n\t\tsumAmplitudes += pbp[i];\r\n\t}\r\n\r\n\tfor (i = 0; i < config.freqBinCount / 2; i++)\r\n\t\tpbp[i] /= sumAmplitudes;\r\n\r\n\tratio = maxpbp / (meanpbs + 1);\r\n\tjDiff = jensenDiff(pbp, config.freqBinCount);\r\n\r\n\tif (ratio > config.whistleBlockThreshold && jDiff > config.jDiffThreshold) {\r\n\t\tpositiveSamples++;\r\n\r\n\t\tif (positiveSamples > config.sampleThreshold) {\r\n\t\t\twhistleCallback({\r\n\t\t\t\tratio: ratio,\r\n\t\t\t\tjDiff: jDiff\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tif (totalSamples === 50) {\r\n\t\ttotalSamples = 0;\r\n\t\tpositiveSamples = 0;\r\n\t} else {\r\n\t\ttotalSamples += 1;\r\n\t}\r\n\r\n\traf(whistleFinder.bind(this, analyser, whistleCallback));\r\n}\r\n\r\nvar whistlerr = function (whistleCallback) {\r\n\tvar audioContext = new AudioContext();\r\n\r\n\tnavigator.getUserMedia = (navigator.getUserMedia ||\r\n\t\tnavigator.webkitGetUserMedia ||\r\n\t\tnavigator.mozGetUserMedia ||\r\n\t\tnavigator.msGetUserMedia);\r\n\r\n\tfunction getUserMedia(dictionary, callback, error) {\r\n\t\ttry {\r\n\t\t\tif (!navigator.getUserMedia) {\r\n\t\t\t\tnavigator.mediaDevices.getUserMedia(dictionary).then(callback).catch(error);\r\n\t\t\t} else {\r\n\t\t\t\tnavigator.getUserMedia(dictionary, callback, error);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\talert('getUserMedia threw exception :' + e);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction gotStream(stream) {\r\n\t\t// Create an AudioNode from the stream.\r\n\t\tvar mediaStreamSource = audioContext.createMediaStreamSource(stream);\r\n\t\t// Connect it to the destination.\r\n\t\tvar analyser = audioContext.createAnalyser();\r\n\t\tanalyser.fftSize = config.freqBinCount;\r\n\r\n\t\tmediaStreamSource.connect(analyser);\r\n\t\twhistleFinder(analyser, whistleCallback);\r\n\t}\r\n\r\n\tgetUserMedia({ audio: true }, gotStream, function () {\r\n\t\talert(\"There was an error accessing audio input. Please check.\");\r\n\t});\r\n};\r\n\r\nmodule.exports = {\r\n\tsetConfig,\r\n\tdetect: whistlerr,\r\n\twhistleFinder\r\n};\n\n//# sourceURL=webpack://whistlerr/./index.js?");

/***/ }),

/***/ "./lib/dspFilter.js":
/*!**************************!*
  !*** ./lib/dspFilter.js ***!
  \**************************/
/***/ ((module) => {

eval("function bandPassFilter(spectrum, config){\n\tvar spectrumClone = spectrum.slice(); // spectrumClone the Array\n\n\tvar freqPerSpectrumElement = config.sampleRate / (spectrumClone.length * 2);\n\n\tfor( var i = 0; spectrumClone[i] !== undefined; i++ ) {\n\t\tif( i * freqPerSpectrumElement < config.fLower || i * freqPerSpectrumElement > config.fUpper )\n\t\t\tspectrumClone[i] = 0.15;\n\t}\n\n\treturn spectrumClone;\n}\n\nfunction bandStopFilter(spectrum, config){\n\tvar spectrumClone = spectrum.slice(); // spectrumClone the Array\n\n\tvar freqPerSpectrumElement = config.sampleRate / (spectrumClone.length * 2);\n\n\tfor( var i = 0; spectrumClone[i] !== undefined; i++ ) {\n\n\t\tif( i * freqPerSpectrumElement > config.fLower && i * freqPerSpectrumElement < config.fUpper )\n\t\t\tspectrumClone[i] = 0.15;\n\t}\n\n\treturn spectrumClone;\n}\n\nmodule.exports = {\n\tbandpass: bandPassFilter,\n\tbandstop: bandStopFilter\n};\n\n//# sourceURL=webpack://whistlerr/./lib/dspFilter.js?");

/***/ }),

/***/ "./lib/fft.js":
/*!********************!*
  !*** ./lib/fft.js ***!
  \********************/
/***/ ((module) => {

eval("function setupTypedArray(name, fallback) {\n  if (typeof this[name] !== \"function\" && typeof this[name] !== \"object\") {\n    if (typeof this[fallback] === \"function\" && typeof this[fallback] !== \"object\") {\n      this[name] = this[fallback];\n    } else {\n      this[name] = function(obj) {\n        if (obj instanceof Array) {\n          return obj;\n        } else if (typeof obj === \"number\") {\n          return new Array(obj);\n        }\n      };
    }
  }
}\n\nsetupTypedArray(\"Float32Array\", \"WebGLFloatArray\");\nsetupTypedArray(\"Int32Array\",   \"WebGLIntArray\");\nsetupTypedArray(\"Uint16Array\",  \"WebGLUnsignedShortArray\");\nsetupTypedArray(\"Uint8Array\",   \"WebGLUnsignedByteArray\");\n\nfunction FourierTransform(bufferSize, sampleRate) {\n  this.bufferSize = bufferSize;\n  this.sampleRate = sampleRate;\n  this.bandwidth  = 2 / bufferSize * sampleRate / 2;\n\n  this.spectrum   = new Float32Array(bufferSize/2);\n  this.real       = new Float32Array(bufferSize);\n  this.imag       = new Float32Array(bufferSize);\n\n  this.peakBand   = 0;\n  this.peak       = 0;\n\n  this.getBandFrequency = function(index) {\n    return this.bandwidth * index + this.bandwidth / 2;\n  };\n\n  this.calculateSpectrum = function() {\n    var spectrum  = this.spectrum,\n        real      = this.real,\n        imag      = this.imag,\n        bSi       = 2 / this.bufferSize,\n        sqrt      = Math.sqrt,\n        rval,\n        ival,\n        mag;\n\n    for (var i = 0, N = bufferSize/2; i < N; i++) {\n      rval = real[i];\n      ival = imag[i];\n      mag = sqrt(rval * rval + ival * ival);\n\n      if (mag > this.peak) {\n        this.peakBand = i;\n        this.peak = mag;\n      }\n\n      spectrum[i] = mag;\n    }\n  };\n}\n\nfunction FFT(bufferSize, sampleRate) {\n  FourierTransform.call(this, bufferSize, sampleRate);\n\n  this.reverseTable = new Uint32Array(bufferSize);\n\n  var limit = 1;\n  var bit = bufferSize >> 1;\n\n  var i;\n\n  while (limit < bufferSize) {\n    for (i = 0; i < limit; i++) {\n      this.reverseTable[i + limit] = this.reverseTable[i] + bit;\n    }\n\n    limit = limit << 1;\n    bit = bit >> 1;\n  }\n\n  this.sinTable = new Float32Array(bufferSize);\n  this.cosTable = new Float32Array(bufferSize);\n\n  for (i = 0; i < bufferSize; i++) {\n    this.sinTable[i] = Math.sin(-Math.PI/i);\n    this.cosTable[i] = Math.cos(-Math.PI/i);\n  }\n}\n\nFFT.prototype.forward = function(buffer) {\n  var bufferSize      = this.bufferSize,\n      cosTable        = this.cosTable,\n      sinTable        = this.sinTable,\n      reverseTable    = this.reverseTable,\n      real            = this.real,\n      imag            = this.imag,\n      spectrum        = this.spectrum;\n\n  var k = Math.floor(Math.log(bufferSize) / Math.LN2);\n\n  if (Math.pow(2, k) !== bufferSize) { throw \"Invalid buffer size, must be a power of 2.\"; }\n  if (bufferSize !== buffer.length)  {\n    throw \"Supplied buffer is not the same size as defined FFT. FFT Size: \" + bufferSize + \" Buffer Size: \" + buffer.length;\n  }\n\n  var halfSize = 1,\n      phaseShiftStepReal,\n      phaseShiftStepImag,\n      currentPhaseShiftReal,\n      currentPhaseShiftImag,\n      off,\n      tr,\n      ti,\n      tmpReal,\n      i;\n\n  for (i = 0; i < bufferSize; i++) {\n    real[i] = buffer[reverseTable[i]];\n    imag[i] = 0;\n  }\n\n  while (halfSize < bufferSize) {\n    phaseShiftStepReal = cosTable[halfSize];\n    phaseShiftStepImag = sinTable[halfSize];\n\n    currentPhaseShiftReal = 1;\n    currentPhaseShiftImag = 0;\n\n    for (var fftStep = 0; fftStep < halfSize; fftStep++) {\n      i = fftStep;\n\n      while (i < bufferSize) {\n        off = i + halfSize;\n        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);\n        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);\n\n        real[off] = real[i] - tr;\n        imag[off] = imag[i] - ti;\n        real[i] += tr;\n        imag[i] += ti;\n\n        i += halfSize << 1;\n      }\n\n      tmpReal = currentPhaseShiftReal;\n      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);\n      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);\n    }\n\n    halfSize = halfSize << 1;\n  }\n\n  return this.calculateSpectrum();\n};\n\nmodule.exports = FFT;\n\n//# sourceURL=webpack://whistlerr/./lib/fft.js?\");

/***/ }),

/***/ "./lib/jensenDiff.js":
/*!***************************!*
  !*** ./lib/jensenDiff.js ***!
  \***************************/
/***/ ((module) => {

eval("var Hv_ = 5.545177444479573;\n\nfunction Hv(arr) {\n\tvar sum = 0;\n\n\tfor( var i = 0; arr[i] !== undefined; i++)\n\t\tsum -= arr[i] * Math.log(arr[i]);\n\n\treturn sum;\n}\n\nfunction HvHv_ ( arr, freqBinCount ) {\n\tvar sum = 0;\n\n\tfor( var i = 0; arr[i] !== undefined; i++) {\n\t\tvar X = (arr[i] + 2 / freqBinCount) / 2;\n\t\tsum -= X * Math.log(X);\n\t}\n\n\treturn sum;\n\n}\n\nfunction jensenDiff( spectrum, freqBinCount ) {\n\treturn HvHv_(spectrum, freqBinCount) - (Hv(spectrum) + Hv_) / 2;\n}\n\nmodule.exports = jensenDiff;\n\n//# sourceURL=webpack://whistlerr/./lib/jensenDiff.js?\");

/***/ }),

/***/ "./lib/smqt.js":
/*!*********************!*
  !*** ./lib/smqt.js ***!
  \*********************/
/***/ ((module) => {

eval("var SMQT = {\n\ttimeArr : [],\n\tsmqtArr : [],\n\n\tmaxLevel : 0,\n\n\tinit : function( timeArr, maxLevel){\n\t\tthis.timeArr = timeArr;\n\t\tthis.maxLevel = maxLevel;\n\n\t\treturn this;\n\t},\n\n\tcalculate : function(){\n\t\tthis.smqtArr = this.SMQT( this.timeArr, 1);\n\n\t\treturn this;\n\t},\n\n\taddUp : function(a, b, c) {\n\t\tvar catArr = b.concat(c);\n\n\t\tfor(var i = 0; i < catArr.length ; i++) {\n\t\t\ta[i] += catArr[i];\n\t\t}\n\n\t\treturn a;\n\t},\n\n\tSMQT : function( time_arr, currLevel )\n\t{\n\t\tif( currLevel === this.maxLevel + 1)\n\t\t\treturn [];\n\n\t\tvar U = [], one_set = [], zero_set = [], sum_samples = 0, avg_samples;\n\n\t\tfor( var i = 0; i < time_arr.length; i++ ) {\n\t\t\tsum_samples += time_arr[i];\n\t\t}\n\n\t\tavg_samples = sum_samples / time_arr.length;\n\n\t\tfor( i = 0; i < time_arr.length; i++ ) {\n\t\t\tif( time_arr[i] >= avg_samples ) {\n\t\t\t\tU.push( 1 * Math.pow(2, this.maxLevel - currLevel) ); // conversion from binary \"1\" to its integer form\n\t\t\t\tone_set.push(time_arr[i]);\n\t\t\t} else {\n\t\t\t\tU.push(0);\n\t\t\t\tzero_set.push(time_arr[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn this.addUp(U, this.SMQT(one_set, currLevel + 1), this.SMQT(zero_set, currLevel + 1));\n\t},\n\n\tnormalize : function(){\n\t\tfor ( var i = 0; i < this.smqtArr.length; i++)\n\t\t\tthis.smqtArr[i] = (this.smqtArr[i] - Math.pow(2, this.maxLevel - 1)) / Math.pow(2, this.maxLevel - 1);\n\n\t\treturn this.smqtArr;\n\t}\n\n};\n\nmodule.exports = SMQT;\n\n//# sourceURL=webpack://whistlerr/./lib/smqt.js?\");

/***/ }),

/***/ "./node_modules/performance-now/lib/performance-now.js":
/*!*************************************************************!*
  !*** ./node_modules/performance-now/lib/performance-now.js ***!
  \*************************************************************/
/***/ (function(module) {

eval("(function() {\n  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n\n//# sourceMappingURL=performance-now.js.map\n\n\n//# sourceURL=webpack://whistlerr/./node_modules/performance-now/lib/performance-now.js?\");

/***/ }),

/***/ "./node_modules/raf/index.js":
/*!***********************************!*
  !*** ./node_modules/raf/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var now = __webpack_require__(/*! performance-now */ \"./node_modules/performance-now/lib/performance-now.js\")\n  , root = typeof window === 'undefined' ? __webpack_require__.g : window\n  , vendors = ['moz', 'webkit']\n  , suffix = 'AnimationFrame'\n  , raf = root['request' + suffix]\n  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]\n\nfor(var i = 0; !raf && i < vendors.length; i++) {\n  raf = root[vendors[i] + 'Request' + suffix]\n  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix]\n}\n\nif(!raf || !caf) {\n  var last = 0\n    , id = 0\n    , queue = []\n    , frameDuration = 1000 / 60\n\n  raf = function(callback) {\n    if(queue.length === 0) {\n      var _now = now()\n        , next = Math.max(0, frameDuration - (_now - last))\n      last = next + _now\n      setTimeout(function() {\n        var cp = queue.slice(0)\n        queue.length = 0\n        for(var i = 0; i < cp.length; i++) {\n          if(!cp[i].cancelled) {\n            try{\n              cp[i].callback(last)\n            } catch(e) {\n              setTimeout(function() { throw e }, 0)\n            }\n          }\n        }\n      }, Math.round(next))\n    }\n    queue.push({\n      handle: ++id,\n      callback: callback,\n      cancelled: false\n    })\n    return id\n  }\n\n  caf = function(handle) {\n    for(var i = 0; i < queue.length; i++) {\n      if(queue[i].handle === handle) {\n        queue[i].cancelled = true\n      }\n    }\n  }\n}\n\nmodule.exports = function(fn) {\n  return raf.call(root, fn)\n}\nmodule.exports.cancel = function() {\n  caf.apply(root, arguments)\n}\nmodule.exports.polyfill = function(object) {\n  if (!object) {\n    object = root;\n  }\n  object.requestAnimationFrame = raf\n  object.cancelAnimationFrame = caf\n}\n\n//# sourceURL=webpack://whistlerr/./node_modules/raf/index.js?\");

/***/ })

/******/ 	});
/******/ 	var __webpack_module_cache__ = {};
/******/ 	function __webpack_require__(moduleId) {
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		var module = __webpack_module_cache__[moduleId] = {exports: {}};
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 		return module.exports;
/******/ 	}
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	var __webpack_exports__ = __webpack_require__("./demo.js");
/******/ })()
// --- end of whistle.build.js ---
  </script>

  <script>
  // Main app code that uses window.whistlerr
  (function(){
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const sens = document.getElementById('sensitivity');
    const sensVal = document.getElementById('sensVal');
    const durationInput = document.getElementById('duration');
    const log = document.getElementById('log');
    const last = document.getElementById('last');
    const visualizer = document.getElementById('visualizer');
    const autoAdj = document.getElementById('autoAdj');
    const playAlert = document.getElementById('playAlert');

    let audioStream = null;
    let analyserNode = null;
    let audioCtx = null;
    let vizCtx = visualizer.getContext('2d');
    let rafId = null;
    let detectorRunning = false;
    let noiseLevel = 0; // running noise estimate

    // default config mirrors library defaults
    let libConfig = { whistleBlockThreshold: 25, jDiffThreshold: 0.45, sampleThreshold: 10 };

    // helper: update library config
    function applyConfig(){
      if (!window.whistlerr) return;
      window.whistlerr.setConfig({ whistleBlockThreshold: libConfig.whistleBlockThreshold, jDiffThreshold: libConfig.jDiffThreshold, sampleThreshold: libConfig.sampleThreshold });
    }

    // map slider to whistleBlockThreshold (lower = more sensitive). We'll invert slider so that higher slider => more sensitive
    function sliderToThreshold(sliderValue){
      // slider range 5..100; map to whistleBlockThreshold 100..5 (inverted) but keep reasonable bounds
      const v = Math.max(5, Math.min(100, Number(sliderValue)));
      return Math.round(105 - v); // e.g. slider 25 -> 80
    }

    function thresholdToSlider(th){
      return 105 - th;
    }

    sens.addEventListener('input', ()=>{
      sensVal.textContent = sens.value;
      libConfig.whistleBlockThreshold = sliderToThreshold(sens.value);
      applyConfig();
    });

    durationInput.addEventListener('change', ()=>{
      setDurationMs(Number(durationInput.value));
    });

    function setDurationMs(ms){
      // approximate samples per second = 60 (raf). sampleThreshold is number of positive frames needed.
      const fps = 60;
      const threshold = Math.max(1, Math.round(ms / (1000 / fps)));
      libConfig.sampleThreshold = threshold;
      applyConfig();
    }

    // visualizer
    function resizeCanvas(){
      visualizer.width = visualizer.clientWidth * devicePixelRatio;
      visualizer.height = visualizer.clientHeight * devicePixelRatio;
      vizCtx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function drawLoop(){
      if (!analyserNode) return;
      const buf = new Uint8Array(analyserNode.fftSize);
      analyserNode.getByteTimeDomainData(buf);

      vizCtx.clearRect(0,0,visualizer.width,visualizer.height);
      vizCtx.fillStyle = '#081';
      // draw waveform
      vizCtx.beginPath();
      const w = visualizer.clientWidth;
      const h = visualizer.clientHeight;
      for (let i=0;i<buf.length;i++){
        const x = (i/buf.length)*w;
        const y = (buf[i]/128.0)*h/2;
        if (i===0) vizCtx.moveTo(x,y);
        else vizCtx.lineTo(x,y);
      }
      vizCtx.strokeStyle = '#39f';
      vizCtx.lineWidth = 1.5;
      vizCtx.stroke();

      // simple spectrum
      const spec = new Uint8Array(analyserNode.frequencyBinCount);
      analyserNode.getByteFrequencyData(spec);
      vizCtx.fillStyle = 'rgba(200,200,200,0.12)';
      const bw = w / spec.length;
      for (let i=0;i<spec.length;i++){
        const rh = (spec[i]/255)*h*0.35;
        vizCtx.fillRect(i*bw, h-rh, bw-1, rh);
      }

      // update running noise level (RMS)
      let sum = 0;
      for (let i=0;i<buf.length;i++){ const v = (buf[i]-128)/128; sum += v*v; }
      const rms = Math.sqrt(sum / buf.length);
      noiseLevel = 0.98*noiseLevel + 0.02*rms; // smoothing

      // auto adjust sensitivity if enabled
      if (autoAdj.checked){
        // if noiseLevel high, increase whistleBlockThreshold (less sensitive), else lower it
        const noiseLimit = 0.035; // empirical
        const target = noiseLevel > noiseLimit ? Math.min(120, libConfig.whistleBlockThreshold + Math.round((noiseLevel - noiseLimit)*500)) : Math.max(5, libConfig.whistleBlockThreshold - 1);
        // slowly move towards target
        libConfig.whistleBlockThreshold = Math.round(libConfig.whistleBlockThreshold*0.9 + target*0.1);
        applyConfig();
        // update slider to reflect change
        sens.value = thresholdToSlider(libConfig.whistleBlockThreshold);
        sensVal.textContent = sens.value;
      }

      rafId = requestAnimationFrame(drawLoop);
    }

    function appendLog(text){
      const line = document.createElement('div');
      line.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
      log.prepend(line);
      while (log.children.length>200) log.removeChild(log.lastChild);
    }

    // play alert
    const alertOsc = new (window.AudioContext || window.webkitAudioContext)();
    function playBeep(){
      try{
        const o = alertOsc.createOscillator();
        const g = alertOsc.createGain();
        o.type = 'sine'; o.frequency.value = 1400; g.gain.value = 0.0015;
        o.connect(g); g.connect(alertOsc.destination);
        o.start();
        g.gain.exponentialRampToValueAtTime(0.0001, alertOsc.currentTime + 0.25);
        setTimeout(()=>o.stop(),300);
      }catch(e){/*ignore*/}
    }

    // integrate with library
    let detectCancel = null;

    startBtn.addEventListener('click', async ()=>{
      if (detectorRunning) return;
      try{
        // reset log
        log.textContent = '';
        appendLog('Solicitando permiso de micrófono...');

        // start detection using provided library
        if (!window.whistlerr) { appendLog('La librería no se cargó.'); return; }

        // set initial config
        libConfig.whistleBlockThreshold = sliderToThreshold(sens.value);
        setDurationMs(Number(durationInput.value));
        applyConfig();

        window.whistlerr.detect(function(ev){
          // ev: { ratio, jDiff }
          const text = `Silbido detectado — ratio:${ev.ratio.toFixed(2)} jDiff:${ev.jDiff.toFixed(3)} thresh:${libConfig.whistleBlockThreshold} durSamples:${libConfig.sampleThreshold}`;
          appendLog(text);
          last.textContent = text;
          if (playAlert.checked) playBeep();
        });

        // The library creates its own audio context and analyser, but we want to visualize. We can try to reuse by creating getUserMedia here too.
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioStream = stream;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const src = audioCtx.createMediaStreamSource(stream);
        analyserNode = audioCtx.createAnalyser();
        analyserNode.fftSize = 512;
        src.connect(analyserNode);
        detectorRunning = true;
        startBtn.disabled = true; stopBtn.disabled = false;
        appendLog('Escuchando...');
        drawLoop();

      }catch(err){
        appendLog('Error iniciando micrófono: '+err.message);
      }
    });

    stopBtn.addEventListener('click', ()=>{
      if (!detectorRunning) return;
      detectorRunning = false;
      startBtn.disabled = false; stopBtn.disabled = true;
      if (audioStream){ audioStream.getTracks().forEach(t=>t.stop()); audioStream = null; }
      if (audioCtx){ try{ audioCtx.close(); }catch(e){} audioCtx=null; }
      if (rafId) cancelAnimationFrame(rafId);
      appendLog('Detenido');
    });

    // initialize UI values
    sensVal.textContent = sens.value;
    setDurationMs(Number(durationInput.value));

    // expose for debugging
    window._whistle_tool = { setDurationMs, libConfig };
  })();
  </script>
</body>
</html>
